\section{Compression des modèles}

Pour mieux appréhender la variété de l'environnement et des outils la première tâche qui m'a été confiée n'était pas réellement au cœur de ses systèmes.

Pour pouvoir s'adapter et selon le principe du \emph{model@runtime} chaque nœud d'un réseau IoT doit comparer le nouveau modèle du réseau avec le courant et en déduire s'il doit se modifier. Il est donc nécessaire que le nouveau modèle soit échangé entre tous les nœuds. Dans un soucis de temps de développement et puisque cela n'impacte pas l'idée de \emph{model@runtime} l'implémentation de \emph{kevoree-c} ne compresse pas les modèles avant de les transmettre aux pairs voisins.

\subsection{Premier développement sur Contiki}

Mettre un place le compilateur

le plus simple est de compiler à côté du système et produire un binaire pour m3

\subsection{État de l'art sur PC}

valgrind

compiler en 32bit pour réduire la taille des pointeurs

\subsection{Tentatives de portage}

trop de limite, 

\subsection{Table d'association}

Re blabla sur les limites du systèms

les différentes approches envisagées 

le tableau comparatif des implém existantes
Juste un graphe des ratios et des utilisations de ressources
En annexe le détail des résultats mesurés.


La méthode retenue,

le package contiki crée


\section{Parser spécifique}

\section{Compilation}

Le gros du stage pour le moment

\subsection{L'intérêt de générer du code}

\subsection{Un vrai compilateur et pas juste une transcription de modèle}